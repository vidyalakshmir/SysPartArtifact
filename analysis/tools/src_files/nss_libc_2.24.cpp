/*
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   * Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *   * Neither the name of Brown University nor the
 *     names of its contributors may be used to endorse or promote products
 *     derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <fstream>
#include <set>
#include <sstream>
#include <string>

#include "conductor/filesystem.h"
#include "nss.h"

//#include "log.h"

NSSFuncsPass::NSSFuncsPass() {
    setupFuncs();
    loadConf();
}

void NSSFuncsPass::visit(Module *module) {
    if (!module->getExternalSymbolList()) return;

    for (auto extsymb : CIter::children(module->getExternalSymbolList())) {
        auto it = funcs.find(extsymb->getName());
        if (it == funcs.end()) continue;

      
        std::map<std::string, std::vector<std::string>> libneeded;
        auto liblist = databaselibs[it->second];
        for (auto lib : liblist) {
           // CLOG(1, "\tnss library needed: %s", lib.c_str());
            libneeded[lib].push_back("_nss_" + lib + "_" + extsymb->getName());
        }
        struct info inf1;
        inf1.module = module;
        inf1.ext_symb = extsymb->getName();
        inf1.libneeded = libneeded;
        ns_info.push_back(inf1);
    }
}

void NSSFuncsPass::setupFuncs() {
    // the following is generated by a shell script from the glibc 2.27 source
    // thankfully the API is not likely to change any time in the near future
    funcs["setgrent_r"] = "group";
    funcs["getgrent_r"] = "group";
    funcs["endgrent_r"] = "group";
    funcs["setsgent_r"] = "gshadow";
    funcs["getsgent_r"] = "gshadow";
    funcs["endsgent_r"] = "gshadow";
    funcs["setpwent_r"] = "passwd";
    funcs["getpwent_r"] = "passwd";
    funcs["endpwent_r"] = "passwd";
    funcs["setrpcent_r"] = "rpc";
    funcs["getrpcent_r"] = "rpc";
    funcs["endrpcent_r"] = "rpc";
    funcs["setspent_r"] = "shadow";
    funcs["getspent_r"] = "shadow";
    funcs["endspent_r"] = "shadow";
    funcs["setservent_r"] = "services";
    funcs["getservent_r"] = "services";
    funcs["endservent_r"] = "services";
    funcs["setaliasent_r"] = "aliases";
    funcs["getaliasent_r"] = "aliases";
    funcs["endaliasent_r"] = "aliases";
    funcs["sethostent_r"] = "hosts";
    funcs["gethostent_r"] = "hosts";
    funcs["endhostent_r"] = "hosts";
    funcs["setprotoent_r"] = "protocols";
    funcs["getprotoent_r"] = "protocols";
    funcs["endprotoent_r"] = "protocols";
    funcs["setnetent_r"] = "networks";
    funcs["getnetent_r"] = "networks";
    funcs["endnetent_r"] = "networks";
    funcs["setgrent"] = "group";
    funcs["getgrent"] = "group";
    funcs["endgrent"] = "group";
    funcs["setsgent"] = "gshadow";
    funcs["getsgent"] = "gshadow";
    funcs["endsgent"] = "gshadow";
    funcs["setpwent"] = "passwd";
    funcs["getpwent"] = "passwd";
    funcs["endpwent"] = "passwd";
    funcs["getrpcent"] = funcs["getrpcent_r"];
    funcs["setspent"] = "shadow";
    funcs["getspent"] = "shadow";
    funcs["endspent"] = "shadow";
    funcs["getaliasent"] = funcs["getaliasent_r"];
    funcs["gethostent"] = funcs["gethostent_r"];
    funcs["getnetent"] = funcs["getnetent_r"];
    funcs["getservent"] = funcs["getservent_r"];
    funcs["getprotoent"] = funcs["getprotoent_r"];
    funcs["getgrgid"] = "group";
    funcs["getgrnam"] = "group";
    funcs["getsgnam"] = "gshadow";
    funcs["getpwnam"] = "passwd";
    funcs["getpwuid"] = "passwd";
    funcs["getrpcbyname"] = "rpc";
    funcs["getrpcbynumber"] = "rpc";
    funcs["getspnam"] = "shadow";
    funcs["getprotobynumber"] = "protocols";
    funcs["getservbyport"] = "services";
    funcs["getaliasbyname"] = "aliases";
    funcs["getservbyname"] = "services";
    funcs["getnetbyaddr"] = "networks";
    funcs["getprotobyname"] = "protocols";
    funcs["gethostbyaddr"] = "hosts";
    funcs["getnetbyname"] = "networks";
    funcs["gethostbyname2"] = "hosts";
    funcs["gethostbyname"] = "hosts";
    funcs["getgrnam_r"] = "group";
    funcs["getgrgid_r"] = "group";
    funcs["getsgnam_r"] = "gshadow";
    funcs["getpwnam_r"] = "passwd";
    funcs["getpwuid_r"] = "passwd";
    funcs["getrpcbynumber_r"] = "rpc";
    funcs["getrpcbyname_r"] = "rpc";
    funcs["getspnam_r"] = "shadow";
    funcs["getnetbyname_r"] = "networks";
    funcs["getaliasbyname_r"] = "aliases";
    funcs["getnetbyaddr_r"] = "networks";
    funcs["gethostbyname2_r"] = "hosts";
    funcs["getprotobynumber_r"] = "protocols";
    funcs["getservbyport_r"] = "services";
    funcs["getprotobyname_r"] = "protocols";
    funcs["getservbyname_r"] = "services";
    funcs["gethostbyname_r"] = "hosts";
    funcs["gethostbyaddr_r"] = "hosts";
}

void NSSFuncsPass::loadConf() {
    std::ifstream conf(ConductorFilesystem::getInstance()
                           ->transform("/etc/nsswitch.conf")
                           .c_str());
    std::string line;
    while (std::getline(conf, line)) {
        if (line.length() == 0 || line[0] == '#') continue;

        std::istringstream ss(line);
        std::string db;
        ss >> db;
        if (db.back() != ':') {
            //LOG(1, "Unknown nsswitch.conf file format!");
            continue;
        }

        db.pop_back();
        auto &liblist = databaselibs[db];

        std::string lib;
        while (ss >> lib) {
            if (lib[0] == '[') continue;
            if(lib == "compat" || lib =="db" || lib == "dns" || lib == "files" || lib =="hesiod" || lib =="nis" || lib == "nisplus") //These are the libnss libraries provide in glibc-2.24
                liblist.push_back(lib);
            
        }
    }
}